module CruiseStateFSM:
	constant SPEEDMIN : float = 30.0;
	constant SPEEDMAX : float = 150.0;
	constant PEDALSMIN : float = 3.0;

	input fsmOn, fsmOff, fsmResume, fsmSet, fsmQuickAccel, fsmQuickDecel;
	input fsmSpeed : float, fsmAccel : float, fsmBrake : float;
	output fsmCruiseSpeed : float;
	output fsmCruiseState: CRUISESTATES;
	
	var state := 0 integer in
	emit fsmCruiseState = OFF;
	loop
		trap T1 in
			pause

			%OFF state
			if state = 0 then
				%Handle state changes
				present pre(fsmOn) then
					emit fsmCruiseState = ON;
					state := 1;
				end present;
				exit T1;
			end if;

			%ON state
			if state == 1 then
				% Call the CruiseSpeedFlow submodule
				run CruiseSpeedFlow[fsmOn/csmOn, 
									fsmSet/csmSet, 
									fsmQuickAccel/csmQuickAccel, 
									fsmQuickDecel/csmQuickDecel,
									fsmSpeed/csmSpeed, 
									fsmCruiseSpeed/csmCruiseSpeed]
				%Handle state changes
				present pre(fsmOff) then 
					emit fsmCruiseState = OFF;
					state := 0;
				end present;
				if pre(?fsmBrake > PEDALSMIN) then
					emit fsmCruiseState = STANDBY;
					state := 2;
				end if;
				if pre(?fsmAccel > PEDALSMIN) or pre(?fsmSpeed) > SPEEDMAX or pre(?fsmSpeed) < SPEEDMIN then
					emit fsmCruiseState = DISABLE;
					state := 3;
				end if;
				exit T1;
			end if;

			%STANDBY state
			if state == 2 then
				%Call the CruiseSpeedFlow submodule 
				run CruiseSpeedFlow[fsmOn/csmOn, 
									fsmSet/csmSet, 
									fsmQuickAccel/csmQuickAccel, 
									fsmQuickDecel/csmQuickDecel,
									fsmSpeed/csmSpeed, 
									fsmCruiseSpeed/csmCruiseSpeed]
				%Handle state changes
				present pre(fsmOff) then 
					emit fsmCruiseState = OFF;
					state := 0;
				end present;
				if pre(?fsmBrake < PEDALSMIN) and pre(?fsmSpeed) < SPEEDMAX and pre(?fsmSpeed) > SPEEDMIN then
					emit fsmCruiseState = ON;
					state := 1;
				end if;
				if pre(?fsmBrake < PEDALSMIN) and (pre(?fsmSpeed) > SPEEDMAX or pre(?fsmSpeed) < SPEEDMIN) then
					emit fsmCruiseState = DISABLE;
					state := 3;
				end if;
				exit T1;
			end if;

			%DISABLE state
			if state == 3 then
				%Call the CruiseSpeedFlow submodule
				run CruiseSpeedFlow[fsmOn/csmOn, 
									fsmSet/csmSet, 
									fsmQuickAccel/csmQuickAccel, 
									fsmQuickDecel/csmQuickDecel,
									fsmSpeed/csmSpeed, 
									fsmCruiseSpeed/csmCruiseSpeed]
				%Handle state changes
				present pre(fsmOff) then
					emit fsmCruiseState = OFF;
					state := 0;
				end present;
				if pre(?fsmAccel < PEDALSMIN) and pre(?fsmSpeed) < SPEEDMAX and pre(?fsmSpeed) > SPEEDMIN then
					emit fsmCruiseState = ON;
					state := 1;
				end if;
				if pre(?fsmBrake > PEDALSMIN) then
					emit fsmCruiseState = STANDBY;
					state := 2;
				end if;
				exit T1;
			end if;
		end trap
	end loop
	end var
end module

module CruiseSpeedFlow:
	constant SPEEDMIN : float = 30.0;
	constant SPEEDMAX : float = 150.0;
	constant SPEEDINC : float = 2.5;

	input csmOn, csmSet, csmQuickAccel, csmQuickDecel;
	input csmSpeed : float;
	output csmCruiseSpeed : float;
	
	var temp := 0.0 : float;

	%Setting speed
	present csmOn or csmSet then
		temp := csmSpeed;
	end present;

	%Handling quick accelerations/decelerations
	present csmQuickAccel then
		if (temp != 0.0) then
			temp := temp += SPEEDINC;
		end if;
	end present;
	present csmQuickDevel then
		if (temp != 0.0) then
			temp := temp -= SPEEDINC;
		end if;
	end present;

	%Making sure speed stays within boundaries set
	if temp > SPEEDMAX then
		temp := SPEEDMAX;
	end if;
	if temp < SPEEDMIN then
		temp := SPEEDMIN;
	end if;
	emit csmCruiseSpeed(temp);

	end var
end module

module CarSpeedControl:
	constant KP : float = 8.112;
	constant KI : float = 0.5;
	constant THROTTLESATMAX : float = 45.0;

	output cscThrottleCmd : float;
	loop
	emit cscThrottleCmd(0.0);
	end loop
end module

module cruiseController:
	type CRUISESTATES = enum { ON, OFF, STANDBY, DISABLE };

	input On, Off, Resume, Set, QuickDecel, QuickAccel; 
	input Accel : float, Brake : float, Speed : float;
	output CruiseSpeed: float, ThrottleCmd : float, CruiseState : CRUISESTATES;
	
	run CruiseStateFSM[ On/fsmOn,
						Off/fsmOff,
						Resume/fsmResume, 
						Set/fsmSet,
						QuickAccel/fsmQuickAccel,
						QuickDecel/fsmQuickDecel,
						Speed/fsmSpeed,
						Accel/fsmAccel,
						Brake/fsmBrake, 
						CruiseSpeed/fsmCruiseSpeed, 
						CruiseState/fsmCruiseState]
	||
	run CarSpeedControl[]

end module
