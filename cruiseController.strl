constant SPEEDMIN : float = 30.0;
constant SPEEDMAX : float = 150.0;
constant SPEEDINC : float = 2.5;
constant KP : float = 8.112;
constant KI : float = 0.5;
constant THROTTLESATMAX : float = 45.0;
constant PEDALSMIN : float = 3.0;

type CRUISESTATES = enum { ON, OFF, STANDBY, DISABLE };

module cruiseController:
	input On, Off, Resume, Set, QuickDecel, QuickAccel; 
	input Accel : float, Brake : float, Speed : float;
	output CruiseSpeed: float, ThrottleCmd : float, CruiseState : CRUISESTATES;
	
	loop
		await immediate On;
		[var accelPressed, brakePressed, accelReleased, brakeReleased, currentSpeed : float in
			run CruiseStateFSM[On/internalOn, Off/internalOff, Resume/internalResume, Set/internalSet, accelPressed/internalAccelPressed, brakePressed/internalBrakePressed, accelReleased/internalAccelReleased, brakeReleased/internalBrakeReleased, currentSpeed/internalCurrentSpeed, CruiseState/internalCruiseState]
			||
			run CruiseSpeedFlow[On/internalOn, Set/internalSet, QuickAccel/internalQuickAccel, QuickDecel/internalQuickDecel, CruiseSpeed/internalCruiseSpeed]
			||
			% Car Driving Control Flowchart
			||
			run BrakePedalFSM[Brake/internalBrake, brakePressed/internalBrakePressed, brakeReleased/internalBrakeReleased]
			||
			run AccelPedalFSM[Accel/internalAccel, accelPressed/internalAccelPressed, accelReleased/internalAccelReleased]
		end var]
	end
end module

module CruiseStateFSM:
	input internalOn, internalOff, internalResume, internalSet, internalAccelPressed, internalBrakePressed;
	input internalCurrentSpeed : float;
	output internalCruiseState: CRUISESTATES;

	loop
		emit internalCruiseState <= OFF;
		await immediate internalOn;
		loop
			emit internalCruiseState <= ON;
			await immediate internalBrakePressed or internalAccelPressed or (internalCurrentSpeed > SPEEDMAX) or (internalCurrentSpeed < SPEEDMIN);
			loop
				emit internalCruise = DISABLE;
				await immediate internalBrakePressed
				emit internalCruiseState = STANDBY;
				await immediate internalBrakeReleased and (internalCurrentSpeed > SPEEDMAX or internalCurrent < SPEEDMIN)
			end
		each (internalCurrentSpeed < SPEEDMAX) and (internalCurrentSpeed > SPEEDMIN) and internalAccelReleased and internalAccelReleased
	each internalOff
end module

module CruiseSpeedFlow:
	input internalOn, internalSet, internalQuickAccel, internalQuickDecel;
	output internalCruiseSpeed : float;
	
	loop
		%where to put pause?
	end
end module

module AccelPedalFSM:
	input internalAccel : float;
	output internalAccelPressed, internalAccelReleased;

	loop
		emit internalAccelReleased
		await immediate (internalAccel > PEDALSMIN);
		emit internalAccelPressed
		await immediate (internalAccel <= PEDALSMIN);
	end
end module

module brakePedalFSM:
	input internalBrake : float;
	output internalBrakePressed, internalBrakeReleased;

	loop
		emit internalBrakeReleased
		await immediate (internalBrake > PEDALSMIN);
		emit internalBrakePressed
		await immediate (internalBrake <= PEDALSMIN);
	end
end module

