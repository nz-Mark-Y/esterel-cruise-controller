module CruiseStateFSM:
	constant SPEEDMIN : float;
	constant SPEEDMAX : float;
	constant PEDALSMIN : float;

	input fsmOn, fsmOff, fsmResume, fsmSet, fsmQuickAccel, fsmQuickDecel;
	input fsmSpeed : float, fsmAccel : float, fsmBrake : float;
	output fsmCruiseSpeed : float;
	output fsmCruiseState: integer;
	
	var state := 1 : integer in
	emit fsmCruiseSpeed(0.0f);
	emit fsmCruiseState(1);
	loop
		%OFF state
		if state = 1 then
			%Handle state changes
			present pre(fsmOn) then
				emit fsmCruiseState(2);
				state := 2;
			end present;

		%ON state
		elsif state = 2 then
			% Call the CruiseSpeedFlow submodule
			run CruiseSpeedFlow[	signal fsmOn/csmOn;
						signal fsmSet/csmSet; 
						signal fsmQuickAccel/csmQuickAccel;
						signal fsmQuickDecel/csmQuickDecel;
						signal fsmSpeed/csmSpeed;
						signal fsmCruiseSpeed/csmCruiseSpeed];
			%Handle state changes
			present pre(fsmOff) then 
				emit fsmCruiseState(1);
				state := 1;
			else
				if pre(?fsmBrake) > PEDALSMIN then
					emit fsmCruiseState(3);
					state := 3;
				elsif pre(?fsmAccel) > PEDALSMIN or pre(?fsmSpeed) > SPEEDMAX or pre(?fsmSpeed) < SPEEDMIN then
					emit fsmCruiseState(4);
					state := 4;
				end if;
			end present;

		%STANDBY state
		elsif state = 3 then
			% Call the CruiseSpeedFlow submodule
			run CruiseSpeedFlow[	signal fsmOn/csmOn;
						signal fsmSet/csmSet; 
						signal fsmQuickAccel/csmQuickAccel;
						signal fsmQuickDecel/csmQuickDecel;
						signal fsmSpeed/csmSpeed;
						signal fsmCruiseSpeed/csmCruiseSpeed];
			%Handle state changes
			present pre(fsmOff) then 
				emit fsmCruiseState(1);
				state := 1;
			else
				if pre(?fsmBrake) < PEDALSMIN and (pre(?fsmSpeed) > SPEEDMAX or pre(?fsmSpeed) < SPEEDMIN) then
					emit fsmCruiseState(4);
					state := 4;
				elsif pre(?fsmBrake) < PEDALSMIN and pre(?fsmSpeed) < SPEEDMAX and pre(?fsmSpeed) > SPEEDMIN then
					emit fsmCruiseState(2);
					state := 2;
				end if;
			end present;

		%DISABLE state
		else
			% Call the CruiseSpeedFlow submodule
			run CruiseSpeedFlow[	signal fsmOn/csmOn;
						signal fsmSet/csmSet; 
						signal fsmQuickAccel/csmQuickAccel;
						signal fsmQuickDecel/csmQuickDecel;
						signal fsmSpeed/csmSpeed;
						signal fsmCruiseSpeed/csmCruiseSpeed];
			%Handle state changes
			present pre(fsmOff) then
				emit fsmCruiseState(1);
				state := 1;
			else
				if pre(?fsmBrake) > PEDALSMIN then
					emit fsmCruiseState(3);
					state := 3;
				elsif pre(?fsmAccel) < PEDALSMIN and pre(?fsmSpeed) < SPEEDMAX and pre(?fsmSpeed) > SPEEDMIN then
					emit fsmCruiseState(2);
					state := 2;
				end if;		
			end present;
		end if;
		pause;
	end loop;
	end var;
end module

module CruiseSpeedFlow:
	constant SPEEDMIN : float;
	constant SPEEDMAX : float;
	constant SPEEDINC : float;

	input csmOn, csmSet, csmQuickAccel, csmQuickDecel;
	input csmSpeed : float;
	inputoutput csmCruiseSpeed : float;
	
	var temp : float in

	%Setting speed
	present pre(csmOn) or pre(csmSet) then
		temp := ?csmSpeed;
	else
		temp := pre(?csmCruiseSpeed);
	end present;

	%Handling quick accelerations/decelerations
	present pre(csmQuickAccel) then
		if (temp > 0.0f or temp < 0.0f) then
			temp := temp + SPEEDINC;
		end if;
	end present;
	present pre(csmQuickDecel) then
		if (temp > 0.0f or temp < 0.0f) then
			temp := temp - SPEEDINC;
		end if;
	end present;

	%Making sure speed stays within boundaries set
	if temp > SPEEDMAX then
		temp := SPEEDMAX;
	end if;
	if temp < SPEEDMIN then
		temp := SPEEDMIN;
	end if;
	emit csmCruiseSpeed(temp);

	end var
end module

module CarSpeedControl:
	input cscCruiseState : integer, cscCruiseSpeed : float, cscSpeed : float, cscAccel : float;
	output cscThrottleCmd : float;

	function regulateThrottle(integer, float, float) : float;
	
	var toRegulate := false : boolean in
	loop
		present(cscCruiseState) then
			if (?cscCruiseState = 2) then
				toRegulate := true;
			else
				toRegulate := false;
			end if;
		end present;

		if toRegulate then
			if (?cscCruiseState = 2 and pre(?cscCruiseState = 1)) then
				emit cscThrottleCmd(regulateThrottle(1, ?cscCruiseSpeed, ?cscSpeed));
			else 
				emit cscThrottleCmd(regulateThrottle(0, ?cscCruiseSpeed, ?cscSpeed));
			end if;
		else
			emit cscThrottleCmd(?cscAccel);
		end if;

		pause;
	end loop
	end var
end module

module cruiseController:
	input On, Off, Resume, Set, QuickDecel, QuickAccel; 
	input Accel : float, Brake : float, Speed : float;
	output CruiseSpeed: float, ThrottleCmd : float, CruiseState : integer;
	
	run CruiseStateFSM[	signal On/fsmOn;
				signal Off/fsmOff;
				signal Resume/fsmResume;
				signal Set/fsmSet;
				signal QuickAccel/fsmQuickAccel;
				signal QuickDecel/fsmQuickDecel;
				signal Speed/fsmSpeed;
				signal Accel/fsmAccel;
				signal Brake/fsmBrake; 
				signal CruiseSpeed/fsmCruiseSpeed; 
				signal CruiseState/fsmCruiseState];
	||
	run CarSpeedControl[signal CruiseState/cscCruiseState;
				signal CruiseSpeed/cscCruiseSpeed;
				signal Speed/cscSpeed;
				signal Accel/cscAccel;
				signal ThrottleCmd/cscThrottleCmd];

end module
