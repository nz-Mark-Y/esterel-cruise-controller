module CruiseStateFSM:
	constant SPEEDMIN : float = 30.0;
	constant SPEEDMAX : float = 150.0;
	constant PEDALSMIN : float = 3.0;

	input internalOn, internalOff, internalResume, internalSet, internalAccel, internalBrake;
	input internalCurrentSpeed : float;
	output internalCruiseState: CRUISESTATES;
	
	var state := 0 integer in
	emit internalCruiseState = OFF;
	loop
		trap T1 in
			await internalOn or internalOff or internalResume or internalSet or internalAccel or internalBrake or internalCurrentSpeed;
			if state = 0 then
				if pre(internalOn) then
					emit internalCruiseState = ON;
					state := 1;
				end if;
				exit T1;
			end if;
			if state = 1 then
				if pre(?internalBrake > PEDALSMIN) then
					emit internalCruiseState = STANDBY;
					state := 2;
				end if;
				if pre(?internalAccel > PEDALSMIN) or pre(?internalCurrentSpeed) > SPEEDMAX or pre(?internalCurrentSpeed) < SPEEDMIN then
					emit internalCruiseState = DISABLE;
					state := 3;
				end if;
				if pre(internalOff) then 
					emit internalCruiseState = OFF;
					state := 0;
				end if;
				exit T1;
			end if;
			if state = 2 then 
				if pre(?internalBrake < PEDALSMIN) and pre(?internalCurrentSpeed) < SPEEDMAX and pre(?internalCurrentSpeed) > SPEEDMIN then
					emit internalCruiseState = ON;
					state := 1;
				end if;
				if pre(?internalBrake < PEDALSMIN) and (pre(?internalCurrentSpeed) > SPEEDMAX or pre(?internalCurrentSpeed) < SPEEDMIN) then
					emit internalCruiseState = DISABLE;
					state := 3;
				end if;
				if pre(internalOff) then 
					emit internalCruiseState = OFF;
					state := 0;
				end if;
				exit T1;
			end if;
			if state = 3 then
				if pre(?internalAccel < PEDALSMIN) and pre(?internalCurrentSpeed) < SPEEDMAX and pre(?internalCurrentSpeed) > SPEEDMIN then
					emit internalCruiseState = ON;
					state := 1;
				end if;
				if pre(?internalBrake > PEDALSMIN) then
					emit internalCruiseState = STANDBY;
					state := 2;
				end if;
				if pre(internalOff) then
					emit internalCruiseState = OFF;
					state := 0;
				end if;
				exit T1;
			end if;
		end trap
	end loop
	end var
end module

module CruiseSpeedFlow:
	constant SPEEDMIN : float = 30.0;
	constant SPEEDMAX : float = 150.0;
	constant SPEEDINC : float = 2.5;

	input internalOn, internalSet, internalQuickAccel, internalQuickDecel;
	input internalCurrentSpeed : float;
	output internalCruiseSpeed : float;
	
	var temp := 0.0 : float;
	loop
		await internalOn or internalSet or internalQuickAccel or internalQuickDecel
		if internalOn or internalSet then
			temp := internalCurrentSpeed;
		end if;
		if internalQuickAccel and (temp != 0.0) then
			temp := temp += SPEEDINC;
		end if;
		if internalQuickDevel and (temp != 0.0) then
			temp := temp -= SPEEDINC;
		end if;
		if temp > SPEEDMAX then
			temp := SPEEDMAX;
		end if;
		if temp < SPEEDMIN then
			temp := SPEEDMIN;
		end if;
		emit internalCruiseSpeed(temp);
	end loop
	end var
end module

module CarSpeedControl:
	constant KP : float = 8.112;
	constant KI : float = 0.5;
	constant THROTTLESATMAX : float = 45.0;


end module

module cruiseController:
	type CRUISESTATES = enum { ON, OFF, STANDBY, DISABLE };

	input On, Off, Resume, Set, QuickDecel, QuickAccel; 
	input Accel : float, Brake : float, Speed : float;
	output CruiseSpeed: float, ThrottleCmd : float, CruiseState : CRUISESTATES;
	
	signal CurrentSpeed : float in
	run CruiseStateFSM[ On/internalOn,
						Off/internalOff,
						Resume/internalResume, 
						Set/internalSet, 
						Accel/internalAccel,
						Brake/internalBrake, 
						CurrentSpeed/internalCurrentSpeed, 
						CruiseState/internalCruiseState]
	||
	run CruiseSpeedFlow[On/internalOn, 
						Set/internalSet, 
						QuickAccel/internalQuickAccel, 
						QuickDecel/internalQuickDecel,
						CurrentSpeed/internalCurrentSpeed, 
						CruiseSpeed/internalCruiseSpeed]
	||
	run CarSpeedControl[]
	end signal
end module