module CruiseStateFSM:
	constant SPEEDMIN : float = 30.0;
	constant SPEEDMAX : float = 150.0;
	constant PEDALSMIN : float = 3.0;

	input internalOn, internalOff, internalResume, internalSet;
	input internalCurrentSpeed : float, internalBrake : float, internalAccel : float;
	output internalCruiseState: CRUISESTATES;
	
	var state := 0 integer in
	emit internalCruiseState = OFF;
	loop
		trap T1 in
			pause

			%OFF state
			if state = 0 then
				%Handle state changes
				if pre(internalOn) then
					emit internalCruiseState = ON;
					state := 1;
				end if;
				exit T1;
			end if;

			%ON state
			if state = 1 then
				%Call the CruiseSpeedFlow submodule
				run CruiseSpeedFlow[internalOn/csmOn, 
										internalSet/csmSet, 
										QuickAccel/csmQuickAccel, 
										QuickDecel/csmQuickDecel,
										internalCurrentSpeed/csmCurrentSpeed, 
										CruiseSpeed/csmCruiseSpeed]
				%Handle state changes
				if pre(internalOff) then 
					emit internalCruiseState = OFF;
					state := 0;
				end if;
				if pre(?internalBrake > PEDALSMIN) then
					emit internalCruiseState = STANDBY;
					state := 2;
				end if;
				if pre(?internalAccel > PEDALSMIN) or pre(?internalCurrentSpeed) > SPEEDMAX or pre(?internalCurrentSpeed) < SPEEDMIN then
					emit internalCruiseState = DISABLE;
					state := 3;
				end if;
				exit T1;
			end if;

			%STANDBY state
			if state = 2 then
				%Call the CruiseSpeedFlow submodule 
				run CruiseSpeedFlow[internalOn/csmOn, 
										internalSet/csmSet, 
										QuickAccel/csmQuickAccel, 
										QuickDecel/csmQuickDecel,
										internalCurrentSpeed/csmCurrentSpeed, 
										CruiseSpeed/csmCruiseSpeed]
				%Handle state changes
				if pre(internalOff) then 
					emit internalCruiseState = OFF;
					state := 0;
				end if;
				if pre(?internalBrake < PEDALSMIN) and pre(?internalCurrentSpeed) < SPEEDMAX and pre(?internalCurrentSpeed) > SPEEDMIN then
					emit internalCruiseState = ON;
					state := 1;
				end if;
				if pre(?internalBrake < PEDALSMIN) and (pre(?internalCurrentSpeed) > SPEEDMAX or pre(?internalCurrentSpeed) < SPEEDMIN) then
					emit internalCruiseState = DISABLE;
					state := 3;
				end if;
				exit T1;
			end if;

			%DISABLE state
			if state = 3 then
				%Call the CruiseSpeedFlow submodule
				run CruiseSpeedFlow[internalOn/csmOn, 
										internalSet/csmSet, 
										QuickAccel/csmQuickAccel, 
										QuickDecel/csmQuickDecel,
										internalCurrentSpeed/csmCurrentSpeed, 
										CruiseSpeed/csmCruiseSpeed]
				%Handle state changes
				if pre(internalOff) then
					emit internalCruiseState = OFF;
					state := 0;
				end if;
				if pre(?internalAccel < PEDALSMIN) and pre(?internalCurrentSpeed) < SPEEDMAX and pre(?internalCurrentSpeed) > SPEEDMIN then
					emit internalCruiseState = ON;
					state := 1;
				end if;
				if pre(?internalBrake > PEDALSMIN) then
					emit internalCruiseState = STANDBY;
					state := 2;
				end if;
				exit T1;
			end if;
		end trap
	end loop
	end var
end module

module CruiseSpeedFlow:
	constant SPEEDMIN : float = 30.0;
	constant SPEEDMAX : float = 150.0;
	constant SPEEDINC : float = 2.5;

	input csmOn, csmSet, csmQuickAccel, csmQuickDecel;
	input csmCurrentSpeed : float;
	output csmCruiseSpeed : float;
	
	var temp := 0.0 : float;

	%Setting speed
	if csmOn or csmSet then
		temp := csmCurrentSpeed;
	end if;

	%Handling quick accelerations/decelerations
	if csmQuickAccel and (temp != 0.0) then
		temp := temp += SPEEDINC;
	end if;
	if csmQuickDevel and (temp != 0.0) then
		temp := temp -= SPEEDINC;
	end if;

	%Making sure speed stays within boundaries set
	if temp > SPEEDMAX then
		temp := SPEEDMAX;
	end if;
	if temp < SPEEDMIN then
		temp := SPEEDMIN;
	end if;
	emit csmCruiseSpeed(temp);

	end var
end module

module CarSpeedControl:
	constant KP : float = 8.112;
	constant KI : float = 0.5;
	constant THROTTLESATMAX : float = 45.0;


end module

module cruiseController:
	type CRUISESTATES = enum { ON, OFF, STANDBY, DISABLE };

	input On, Off, Resume, Set, QuickDecel, QuickAccel; 
	input Accel : float, Brake : float, Speed : float;
	output CruiseSpeed: float, ThrottleCmd : float, CruiseState : CRUISESTATES;
	
	run CruiseStateFSM[ On/internalOn,
						Off/internalOff,
						Resume/internalResume, 
						Set/internalSet, 
						Accel/internalAccel,
						Brake/internalBrake, 
						Speed/internalCurrentSpeed,
						speedManage/internalSpeedManage, 
						CruiseState/internalCruiseState]
	||
	run CruiseSpeedFlow[internalOn/csmOn, 
						internalSet/csmSet, 
						QuickAccel/csmQuickAccel, 
						QuickDecel/csmQuickDecel,
						internalCurrentSpeed/csmCurrentSpeed, 
						CruiseSpeed/csmCruiseSpeed]
	||
	run CarSpeedControl[]

end module